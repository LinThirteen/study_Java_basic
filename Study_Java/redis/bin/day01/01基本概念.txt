

原子性（多线程）：
 	所谓原子性指的是不会被线程调度机制打断的操作，这种操作一旦开始，就
 	一直运行到结束，中间不会有切换到另一个线程


redis:乐观锁
		乐观锁：通过版本号控制，每当数据改变一次就会更新一次版本号
				，多个请求更改同一个数据前都要先核对一下版本号，只有版本号
				相同才能实现操作生效




CAP
nosql数据库(只能三选二)：
	1.C  强一致性
	2.A  可用性
	3.P  分区容错性
	
	
	CA(传统oracle数据库)：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大
	CP(redis)：满足一致性，分区容忍性的系统，通常性能不是特别高
	AP(大多数网站架构的选择)：满足可用性，分区容忍性的系统，通常可能对一致性要求要低一些
	

	redis支持持久化，支持多种数据类型
	memcache不支持持久化，只支持string





	redis支持的数据(指的是键所对应的值的类型):
		
			1.字符串
			2.有序集合
			3.无序集合
			4.列表
			5.hash

	默认16个库，下标从0号库开始
	
	

	redis是单线程+多路IO复用技术：
			
			阻塞IO和非阻塞IO
			 一个IO操作可以分为两个步骤：发起IO请求和实际的IO操作
			阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，
			如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
			 
			 
			IO多路复用：分为 select，poll，epoll
			
			select:我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长32位机默认是1024个。64位机默认是2048.
			
			poll:poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.	

			epoll:不用到处询问，当资源来了就直接调用函数



------------------------基本命令---------------------

		
方法：
	push / pop     主要用于有序的时候
	add / remove


选择1号库: 				 select 1

设置数据：				 set a a

获取数据：				 get a 

查看库中所有的键：		 keys *

判断库中是否存在某个键：	 exists a

查看键的类型：			 type a 

删除键：					 del a

设置过期时间（前提是键已经存在）：  expire  a  10

查看键所剩余的时间：    	ttl a  				(-1)代表永不过期

清空当前库：				flushdb

通杀全部库：				flushall

查看数据库key的个数   		dbsize


同时设定一个或多个key-value对
	mset key value  key2 value key3 value
	
	
同时获取一个或多个key-value对
	mget key key2 key3


同时设定一个或多个key-value,当且仅当(所有)给定的key不存在时
	msetnx key value  key2 value key3 value


获取值的范围(包前也包后)
	getrange key  start  end
	


覆盖字符串
	setrange key <起始位置> value 


设置而键值的同时设置过期时间;
	setex  key  <过期时间> value


以旧换新，设置新值的同时获得旧值
	getset key value














